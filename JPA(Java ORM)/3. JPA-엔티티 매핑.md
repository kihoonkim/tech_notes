# JPA Getting Started - 3

객체와 관계형 데이터베이스의 패러다임의 불일치를 JPA가 어떻게 처리하는지 알아보자.  
- 객체와 테이블 매핑
- 객체와 테이블의 연관관계 처리의 차이
- 객체의 그래프 탐색 vs 테이블의 JOIN
- 객체의 상속 vs 수퍼타입 서브타입

## 엔티티 매핑
#### 객체와 테이블 매핑 Annotation
객체(Entity)와 데이터베이스 Table을 매핑할 때 아래의 어노테이션을 사용한다.
- @Entity: JPA에서 테이블에 매핑할 클래스에 붙임. 해당 클래스는 엔티티라 부른다.
  * 기본생성자(default constructor)는 필수
  * final class, enum, interface, inner class에 사용 불가. final 필드 사용 불가  
  -> runtime시에 javassist에 의해 Entity의 서브클래스 생성하기 때문. 클래스 상속 불가하면 안됨  
- @Table: 엔티티와 매핑할 테이블명을 지정
- @Id: 기본키(primary Key) 매핑
- @Column: 테이블의 컬럼명 매핑. 지정안하는 경우 객체 필드명과 동일하게 지정
- @Enumerated: 자바의 enum 타입을 사용하는 경우 지정
- @Temporal: 날짜 타입(Data, Calendar) 매핑시 사용. (DATE, TIME, TIMESTAMP)
- @Lob: CLOB, BLOB 타입과 매핑시
- @Transient: 테이블 컬럼에 매핑되지 않는 필드에 지정.
- @Access: JPA가 엔티티 데이터에 접근하는 방식 지정. FILED가 기본값. 필드(FILED) or Getter(PROPERTY).

```java
@Enitity
@Table(name="CUSTOMER")
public class Customer {
  @Id
  private String id;

  @Column("FIRST_NAME")
  private String firstName;

  @Column("LAST_NAME")
  private String lastName;

  @Enumerated(EnumType.STRING)
  private CustomerType type;  // public enum CustomerType { GOLD, SILVER, BASIC }

  @Temporal(TemporalType.TIMESTAMP)
  private java.util.Date createdDate;

  @Lob
  private String description;

  @Transient
  private String tempVal;

  @Access(AccessType.PROPERTY)
  public String getFullName() {
    return firstName + " " + lastName;
  }
}
```

#### DB Schema 자동생성
**spring.jpa.hibernate.ddl-auto** 속성을 통해 설정한다.  
```
spring.jpa.hibernate.ddl-auto: validate  # spring.jpa.properties.hibernate.hbm2ddl.auto 속성과 와 동일
```
- create: 기존 테이블 삭제 후 새로 생성
- create-drop: 기존 테이블 삭제 후 새로 생성 + 어플리케이션 종료시 DDL 제거
- update: 테이블과 엔티티 매핑정보 비교 후 변경내용만 반영
- validate: (권장) 테이블과 엔티티 매핑정보 비교 후 변경사항 있는 경우 경고 출력. 어플리케이션 실행 안됨.

#### 기본키 매핑 전략
JPA에서 데이터베이스 기본키 생성 전략을 다음과 같이 지원한다.
- **직접 할당**: em.persist() 호출전에 직접 세팅한다.
```java
Order order = new Order();
order.setId("ORDER_00001");  // pk 직접 생성 후 세팅
em.persist(order);
```
- **IDENTITY**: 기본키 생성을 데이터베이스에 위임. MySQL에서 AUTO_INCREMENT 를 지정해 둔 경우 사용.
영속성 컨텍스트에 엔티티를 저장하려면 반드시 식별자가 필요하기 때문에, IDENTITY 전략 사용시 즉시 DB반영된다.(쓰기지연 X)
```java
@Entity
public class Order {
    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private String id;
    ...
}
```
- **SEQUENCE**: 데이터베이스 시퀀스를 사용하여 기본키를 생성한다.
```java
// CREATE SEQUENCE ORDER_SEQ START WITH 1 INCREMENT BY 1;
@Entity
@SequenceGenerator(name="ORDER_SEQ_GENERATOR", sequenceName="ORDER_SEQ", initialValue=1, allocationSize=1)
public class Order {
    @Id
    @GeneratedValue(strategy=GenerationType.SEQUENCE, getnerator="ORDER_SEQ_GENERATOR")
    private String id;
    ...
}
```
- **TABLE**: 키생성을 위한 전용 테이블을 사용하여 시퀀스와 비슷하게 기본키를 생성한다.  
```java
// CREATE TABLE TB_SEQUENCE ( sequence_name varchar(255) not null, next_val bigint, primary key (sequence_name) )
@Entity
@TableGenerator(name="ORDER_SEQ_GENERATOR", table="TB_SEQUENCE", pkColumnValue="ORDER_SEQ", allocationSize=1)
public class Order {
    @Id
    @GeneratedValue(strategy=GenerationType.TABLE, getnerator="ORDER_SEQ_GENERATOR")
    private String id;
    ...
}
```

| sequence_name  | next_val       |  
| -------------- | -------------- |  
| CUSTOMER_SEQ   | 2              |  
| ORDER_SEQ      | 100            |  
| ...            | ...            |  

> Tip.  
기본키는 변경되면 안되기 때문에,  
직접할당 전략이 아니라면 엔티티에서 setId() 메소드를 비공개하는 것이 좋다.

## 연관관계 매핑
**객체** 는 다른 객체와 **참조(reference)** 를 통해 관계를 맺고,  
**테이블** 은 **외래키(foreign key)** 를 통해서 관계를 맺는다.  
![fig](./images/object-table-relationships.png "")  

객체와 테이블간 연관 관계를 맺는 방식의 차이를 JPA는 다음과 같은 특성을 이용해서 해결한다.  
- **방향(Direction)**: 객체가 다른 객체를 참조하는 방향. **단방향/양방향**  
  테이블은 외래키를 기반으로 테이블간 양방향으로 JOIN이 가능하다. 하지만, 객체의 참조는 항상 단방향이다.
- **다중성(Multiplicity)**: 객체의 관계(Relationships) 표현. **다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)**
- **연관관계의 주인(Owner)**: 객체간 **양방향** 으로 방향성을 가질때 연관관계에 있어 누가 **주인** 인가를 정해야 된다.  
  테이블로 보면 누가 FK를 가져야 하는가의 문제이다.

#### 주요 Annotation
- @ManyToOne: 다대일 관계 매핑
- @OneToMany(mappedBy=""): 일대다 관계 매핑
- @OneToOne: 일대일 관계 매핑
- @ManyToMany: 다대다 관계 매핑
- @JoinColumn(name=""): 외래키 매핑시 사용
- @JoinTable: 다대다 관계를 풀기위해 연결테이블을 사용시 별도 엔티티 생성 없이 매핑

#### 다대일(Many To One)
##### 단방향
![fig](./images/unidirectional ManyToOne.png "")
```java
@Entity
public class Employee {
    @Id @GeneratedValue
    @Column("EMPLOYEE_ID")  
    private int id;

    @ManyToOne
    @JoinColumn(name="DEPARTMENT_ID")  // 외래키 매핑시 사용
    Department dept;

    ...
}

@Entity
public class Department {
    @Id @GeneratedValue
    @Column("DEPARTMENT_ID")  
    private int id;

    ...
}
```
##### 양방향
![fig](./images/bidirectional ManyToOne.png "")
```java
@Entity
public class Employee {
    @Id @GeneratedValue
    @Column("EMPLOYEE_ID")  
    private int id;

    @ManyToOne
    @JoinColumn(name="DEPARTMENT_ID")
    Department dept;

    ...
}

@Entity
public class Department {
    @Id @GeneratedValue
    @Column("DEPARTMENT_ID")  
    private int id;

    @OneToMany(mappedBy="dept")  // 양방향 연관관계 설정 및 연관관계 주인 지정
    private List<Employee> employees = new ArrayList<Employee>();
    ...
}
```

#### 일대다(One To Many)
- 일대다 관계는 항상 다대일 관계의 반대 방향이다.  
- 참조 대상이 다 건이므로 Collection, List, Set, Map 자료구조를 사용한다.  

##### 단방향
```java
@Entity
public class Department {
    @Id @GeneratedValue
    @Column("DEPARTMENT_ID")  
    private int id;

    @OneToMany(mappedBy="dept")  // 양방향 연관관계 설정 및 연관관계 주인 지정
    private List<Employee> employees = new ArrayList<Employee>();
    ...
}

@Entity
public class Employee {
    @Id @GeneratedValue
    @Column("EMPLOYEE_ID")  
    private int id;

    ...
}
```
##### 양방향
- 일대다(1:N) 관계의 양방향은 다대일(N:1) 관계의 양방향과 같은 의미이다.
- 단, **일(1)** 을 연관관계 주인으로 설정하는 방법은 존재하지 않는다.
  연관관계 주인은 외래키가 있는 곳 인데, 이는 항상 **다(N)** 쪽에 존재한다.
- 연관관계 주인 설정은 할 수 없지만, 의미상 표현은 다음과 같이 하면된다.

```java
@Entity
public class Department {
    @Id @GeneratedValue
    @Column("DEPARTMENT_ID")  
    private int id;

    @OneToMany
    @JoinColumn(name="EMPLOYEE_ID")
    private List<Employee> employees = new ArrayList<Employee>();
    ...
}

@Entity
public class Employee {
    @Id @GeneratedValue
    @Column("EMPLOYEE_ID")  
    private int id;

    @ManyToOne
    @JoinColumn(name="DEPARTMENT_ID", insertable=false, updatable=false)
    Department dept;  // <=== ReadOnly 설정
    ...
}
```

#### 일대일(One To One)
일대일은 관계에서 주(Source) 테이블, 대상(Target) 테이블모두 외래키를 갖을 수 있다.  
따라서 어느 테이블에 외래키를 갖을지, 엔티티에서 누가 연관관계의 주인인지를 선택해야 한다.  
아래 그림들에서는 왼쪽을 주 테이블, 오른쪽이 대상 테이블로 정의한다.  

##### 단방향(주 테이블이 외래키를 갖음)
![fig](./images/unidirectional OneToOne-source.png "")
```java
@Entity
public class Employee {
    @Id @GeneratedValue
    @Column("EMPLOYEE_ID")  
    private int id;

    @OneToOne
    @JoinColumn(name="LOCKER_ID")
    private Locker locker;
    ...
}

@Entity
public class Locker {
    @Id @GeneratedValue
    @Column("LOCKER_ID")  
    private int id;

    ...
}
```
##### 양방향(주 테이블이 외래키를 갖음)
![fig](./images/bidirectional OneToOne.png "")
```java
@Entity
public class Employee {
    @Id @GeneratedValue
    @Column("EMPLOYEE_ID")  
    private int id;

    @OneToOne    
    @JoinColumn(name="LOCKER_ID")
    private Locker locker;
    ...
}

@Entity
public class Locker {
    @Id @GeneratedValue
    @Column("LOCKER_ID")  
    private int id;

    @OneToOne(mappedBy="locker")  // 연관관계 주인 설정. 주 테이블(Employee)이 외래키를 갖음.
    private Employee employee;
    ...    
}
```

##### 단방향(대상 테이블이 외래키를 갖음)
![fig](./images/unidirectional OneToOne-source.png "")
위 그림과 같이 참조과

##### 양방향(대상 테이블이 외래키를 갖음)
```java
@Entity
public class Employee {
    @Id @GeneratedValue
    @Column("EMPLOYEE_ID")  
    private int id;

    @OneToOne(mappedBy="employee")  // 연관관계 주인 설정. 대상 테이블(Locker)이 외래키를 갖음.
    private Locker locker;
    ...
}

@Entity
public class Locker {
    @Id @GeneratedValue
    @Column("LOCKER_ID")  
    private int id;

    @OneToOne
    @JoinColumn(name="EMPLOYEE_ID")
    private Employee employee;
    ...    
}
```

#### 다대다(Many To Many)
##### 단방향
![fig](./images/bidirectional ManyToMany.png "")
```java
```
##### 양방향
![fig](./images/unidirectional ManyToMany.png "")
```java
```

## 고급 매핑
- 상속 관계 매핑
- MappedSuperclass
- 복합키와 식별관계 매핑
- 조인 테이블
- 엔티티 하나에 여러 테이블 매핑

## 프록시
- 프록시
- 프록시 심화(15장)
- 즉시로딩, 지연로딩
- 영속성 전이
- 고아객체

## 값 타입
- 기본 값 타입
- 임베디드 타입
- 불변객체
